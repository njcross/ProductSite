============================= test session starts =============================
platform win32 -- Python 3.10.11, pytest-8.3.5, pluggy-1.5.0
rootdir: C:\Users\njcro\m7project\backend
configfile: pytest.ini
plugins: Flask-Dance-7.1.0, flask-1.3.0
collected 32 items

tests\test_auth.py ...                                                   [  9%]
tests\test_auth_routes.py .                                              [ 12%]
tests\test_cart.py .                                                     [ 15%]
tests\test_cart_routes.py .EEE                                           [ 28%]
tests\test_content.py .                                                  [ 31%]
tests\test_content_routes.py .                                           [ 34%]
tests\test_favorite.py .                                                 [ 37%]
tests\test_favorite_routes.py .                                          [ 40%]
tests\test_favorites.py E                                                [ 43%]
tests\test_health_routes.py .                                            [ 46%]
tests\test_kit_routes.py .                                               [ 50%]
tests\test_kits.py ..                                                    [ 56%]
tests\test_newsletter.py ..                                              [ 62%]
tests\test_newsletter_routes.py ..                                       [ 68%]
tests\test_purchase_routes.py .                                          [ 71%]
tests\test_purchases.py .E                                               [ 78%]
tests\test_review_routes.py .                                            [ 81%]
tests\test_reviews.py EE                                                 [ 87%]
tests\test_user_settings.py ...                                          [ 96%]
tests\test_user_settings_routes.py .                                     [100%]

=================================== ERRORS ====================================
_____________________ ERROR at setup of test_add_to_cart ______________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189BE4B9D50>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189BE4BBEB0>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
_________________ ERROR at setup of test_update_cart_quantity _________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189C022BB50>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189C02293F0>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
___________________ ERROR at setup of test_delete_cart_item ___________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189C026A080>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189C0268100>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
____________________ ERROR at setup of test_get_favorites _____________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189BEFAEF50>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189BEC59E10>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
_______________________ ERROR at setup of test_checkout _______________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189BE220820>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189BE222440>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
_____________________ ERROR at setup of test_get_reviews ______________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189C01446A0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189C0144B20>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 2, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE3ADF90>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 2}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
_____________________ ERROR at setup of test_post_review ______________________

self = <sqlalchemy.engine.base.Connection object at 0x00000189C095B8B0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x00000189BDFD9DE0>
context = <sqlalchemy.engine.default.DefaultExecutionContext object at 0x00000189C095A1D0>
statement = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLCompiler_mysqlconnector object at 0x00000189BE4B9750>
parameters = [{'coordinates': None, 'kit_id': 1, 'location': '0,0', 'location_name': 'test', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.IntegrityError: 1048 (23000): Column 'coordinates' cannot be null

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError

The above exception was the direct cause of the following exception:

app = <Flask 'app'>

    @pytest.fixture
    def create_test_kit_and_inventory(app):
        with app.app_context():
            data = {
                "name": "Test Kit",
                "description": "This is a test kit.",
                "price": 19.99,
                "image_url": "http://example.com/testkit.jpg"
            }
            kit_data = kit_schema.load(data)
            new_kit = Kit(**kit_data)
            _db.session.add(new_kit)
            _db.session.commit()  # COMMIT is needed for persistence
            _db.session.flush()  # ensures `id` is assigned
            _db.session.refresh(new_kit)  # binds instance to session with updated fields
            data2 = {
                "location": "0,0",
                "location_name": "test",
                "quantity": "1",
                "kit_id": new_kit.id
            }
            inventory_data = inventory_schema.load(data2)
            new_inventory = inventory_data
            _db.session.add(new_inventory)
>           _db.session.commit()  # COMMIT is needed for persistence

tests\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\orm\scoping.py:597: in commit
    return self._proxied.commit()
venv\lib\site-packages\sqlalchemy\orm\session.py:2028: in commit
    trans.commit(_to_root=True)
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
venv\lib\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv\lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
venv\lib\site-packages\sqlalchemy\orm\session.py:4352: in flush
    self._flush(objects)
venv\lib\site-packages\sqlalchemy\orm\session.py:4487: in _flush
    with util.safe_reraise():
venv\lib\site-packages\sqlalchemy\util\langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\lib\site-packages\sqlalchemy\orm\session.py:4448: in _flush
    flush_context.execute()
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\lib\site-packages\sqlalchemy\engine\base.py:1418: in execute
    return meth(
venv\lib\site-packages\sqlalchemy\sql\elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv\lib\site-packages\sqlalchemy\engine\base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:941: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x00000189BE181D80>
packet = bytearray(b",\x00\x00\x01\xff\x18\x04#23000Column \'coordinates\' cannot be null")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.IntegrityError: (mysql.connector.errors.IntegrityError) 1048 (23000): Column 'coordinates' cannot be null
E           [SQL: INSERT INTO inventory (location, coordinates, location_name, quantity, kit_id) VALUES (%(location)s, %(coordinates)s, %(location_name)s, %(quantity)s, %(kit_id)s)]
E           [parameters: {'location': '0,0', 'coordinates': None, 'location_name': 'test', 'quantity': 1, 'kit_id': 1}]
E           (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\lib\site-packages\mysql\connector\connection.py:648: IntegrityError
============================== warnings summary ===============================
tests/test_auth.py::test_register
  C:\Users\njcro\m7project\backend\app\routes\auth_routes.py:96: SAWarning: relationship 'Kit.purchases' will copy column kits.id to column purchases.kit_id, which conflicts with relationship(s): 'Kit.purchase' (copies kits.id to purchases.kit_id). If this is not the intention, consider if these relationships should be linked with back_populates, or if viewonly=True should be applied to one or more if they are read-only. For the less common case that foreign key constraints are partially overlapping, the orm.foreign() annotation can be used to isolate the columns that should be written towards.   To silence this warning, add the parameter 'overlaps="purchase"' to the 'Kit.purchases' relationship. (Background on this warning at: https://sqlalche.me/e/20/qzyx) (This warning originated from the `configure_mappers()` process, which was invoked automatically in response to a user-initiated operation.)
    user = User(

tests/test_cart_routes.py::test_add_to_cart
tests/test_cart_routes.py::test_update_cart_quantity
tests/test_cart_routes.py::test_delete_cart_item
tests/test_favorites.py::test_get_favorites
tests/test_purchases.py::test_checkout
tests/test_reviews.py::test_get_reviews
tests/test_reviews.py::test_post_review
  C:\Users\njcro\m7project\backend\tests\conftest.py:46: SAWarning: transaction already deassociated from connection
    transaction.rollback()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
ERROR tests/test_cart_routes.py::test_add_to_cart - sqlalchemy.exc.IntegrityE...
ERROR tests/test_cart_routes.py::test_update_cart_quantity - sqlalchemy.exc.I...
ERROR tests/test_cart_routes.py::test_delete_cart_item - sqlalchemy.exc.Integ...
ERROR tests/test_favorites.py::test_get_favorites - sqlalchemy.exc.IntegrityE...
ERROR tests/test_purchases.py::test_checkout - sqlalchemy.exc.IntegrityError:...
ERROR tests/test_reviews.py::test_get_reviews - sqlalchemy.exc.IntegrityError...
ERROR tests/test_reviews.py::test_post_review - sqlalchemy.exc.IntegrityError...
================== 25 passed, 8 warnings, 7 errors in 28.29s ==================
