============================= test session starts =============================
platform win32 -- Python 3.13.1, pytest-8.2.1, pluggy-1.5.0
rootdir: C:\Users\njcro\m7project\backend
configfile: pytest.ini
plugins: Flask-Dance-6.0.0, flask-1.3.0
collected 43 items

tests\test_auth.py FF.                                                   [  6%]
tests\test_auth_routes.py .                                              [  9%]
tests\test_cart.py .                                                     [ 11%]
tests\test_cart_routes.py EEEE                                           [ 20%]
tests\test_content.py .                                                  [ 23%]
tests\test_content_routes.py .                                           [ 25%]
tests\test_favorite.py .                                                 [ 27%]
tests\test_favorite_routes.py .                                          [ 30%]
tests\test_favorites.py E                                                [ 32%]
tests\test_health_routes.py ..                                           [ 37%]
tests\test_inventory_routes.py EEEE                                      [ 46%]
tests\test_kit_routes.py .                                               [ 48%]
tests\test_kits.py E.                                                    [ 53%]
tests\test_newsletter.py E.                                              [ 58%]
tests\test_newsletter_routes.py ...                                      [ 65%]
tests\test_purchase_routes.py .E                                         [ 69%]
tests\test_purchases.py EE                                               [ 74%]
tests\test_resource.py .                                                 [ 76%]
tests\test_resource_routes.py .E                                         [ 81%]
tests\test_review_routes.py .                                            [ 83%]
tests\test_reviews.py .E                                                 [ 88%]
tests\test_user_settings.py .EEE                                         [ 97%]
tests\test_user_settings_routes.py .                                     [100%]

=================================== ERRORS ====================================
____________________ ERROR at setup of test_get_empty_cart ____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def logged_in_client(client, create_test_users):
        user_id, _ = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
_____________________ ERROR at setup of test_add_to_cart ______________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def logged_in_client(client, create_test_users):
        user_id, _ = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
_________________ ERROR at setup of test_update_cart_quantity _________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def logged_in_client(client, create_test_users):
        user_id, _ = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
___________________ ERROR at setup of test_delete_cart_item ___________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def logged_in_client(client, create_test_users):
        user_id, _ = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
____________________ ERROR at setup of test_get_favorites _____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
____________________ ERROR at setup of test_get_inventory _____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
___________________ ERROR at setup of test_create_inventory ___________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
___________________ ERROR at setup of test_update_inventory ___________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
___________________ ERROR at setup of test_delete_inventory ___________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
___________________ ERROR at setup of test_create_character ___________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_auth_header(client, create_test_users):
        """Logs in admin user and returns auth header."""
>       res = client.post('/api/login', json={"username": "admin", "password": "password123"})

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
________________ ERROR at setup of test_get_newsletter_emails _________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_auth_header(client, create_test_users):
        """Logs in admin user and returns auth header."""
>       res = client.post('/api/login', json={"username": "admin", "password": "password123"})

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
___________________ ERROR at setup of test_create_purchase ____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
____________________ ERROR at setup of test_list_purchases ____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
_______________________ ERROR at setup of test_checkout _______________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
________________ ERROR at setup of test_post_and_get_resource _________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def admin_logged_in_client(client, create_test_users):
        _, admin_id = create_test_users
>       with client.session_transaction() as sess:

tests\conftest.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python313\Lib\contextlib.py:148: in __exit__
    next(self.gen)
venv\Lib\site-packages\flask\testing.py:168: in session_transaction
    app.session_interface.save_session(app, sess, resp)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
_____________________ ERROR at setup of test_post_review ______________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
_____________________ ERROR at setup of test_update_email _____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
___________________ ERROR at setup of test_update_password ____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
____________________ ERROR at setup of test_delete_account ____________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    @pytest.fixture
    def user_auth_header(client, create_test_users):
        """Logs in testuser and returns auth header."""
>       res = client.post('/api/login', json={"username": "testuser", "password": "password123"})

tests\conftest.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
================================== FAILURES ===================================
________________________________ test_register ________________________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>

    def test_register(client):
>       response = client.post('/api/register', json={
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "password123",
            "confirmPassword": "password123",
            "restore": False
        })

tests\test_auth.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:209: in save_session
    self.redis.set(
venv\Lib\site-packages\redis\commands\core.py:2342: in set
    return self.execute_command("SET", *pieces, **options)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
_________________________________ test_login __________________________________

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
>           sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )

venv\Lib\site-packages\redis\connection.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\redis\retry.py:46: in call_with_retry
    return do()
venv\Lib\site-packages\redis\connection.py:277: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
venv\Lib\site-packages\redis\connection.py:639: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

venv\Lib\site-packages\redis\connection.py:627: ConnectionRefusedError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'app'>>, create_test_users = (1, 2)

    def test_login(client, create_test_users):
        # Create the users first using the fixture (now they exist)
>       response = client.post('/api/logout')

tests\test_auth.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\werkzeug\test.py:1248: in post
    return self.open(*args, **kw)
venv\Lib\site-packages\flask\testing.py:238: in open
    response = super().open(
venv\Lib\site-packages\werkzeug\test.py:1197: in open
    response = self.run_wsgi_app(request.environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1069: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
venv\Lib\site-packages\werkzeug\test.py:1345: in run_wsgi_app
    app_rv = app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2552: in __call__
    return self.wsgi_app(environ, start_response)
venv\Lib\site-packages\flask\app.py:2532: in wsgi_app
    response = self.handle_exception(e)
venv\Lib\site-packages\flask_cors\extension.py:194: in wrapped_function
    return cors_after_request(app.make_response(f(*args, **kwargs)))
venv\Lib\site-packages\flask\app.py:2529: in wsgi_app
    response = self.full_dispatch_request()
venv\Lib\site-packages\flask\app.py:1826: in full_dispatch_request
    return self.finalize_request(rv)
venv\Lib\site-packages\flask\app.py:1847: in finalize_request
    response = self.process_response(response)
venv\Lib\site-packages\flask\app.py:2344: in process_response
    self.session_interface.save_session(self, ctx.session, response)
venv\Lib\site-packages\flask_session\sessions.py:196: in save_session
    self.redis.delete(self.key_prefix + session.sid)
venv\Lib\site-packages\redis\commands\core.py:1713: in delete
    return self.execute_command("DEL", *names)
venv\Lib\site-packages\redis\client.py:542: in execute_command
    conn = self.connection or pool.get_connection(command_name, **options)
venv\Lib\site-packages\redis\connection.py:1109: in get_connection
    connection.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Connection<host=localhost,port=6379,db=0>

    def connect(self):
        "Connects to the Redis server if not already connected"
        if self._sock:
            return
        try:
            sock = self.retry.call_with_retry(
                lambda: self._connect(), lambda error: self.disconnect(error)
            )
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.

venv\Lib\site-packages\redis\connection.py:282: ConnectionError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
Database tables created!
=========================== short test summary info ===========================
FAILED tests/test_auth.py::test_register - redis.exceptions.ConnectionError: ...
FAILED tests/test_auth.py::test_login - redis.exceptions.ConnectionError: Err...
ERROR tests/test_cart_routes.py::test_get_empty_cart - redis.exceptions.Conne...
ERROR tests/test_cart_routes.py::test_add_to_cart - redis.exceptions.Connecti...
ERROR tests/test_cart_routes.py::test_update_cart_quantity - redis.exceptions...
ERROR tests/test_cart_routes.py::test_delete_cart_item - redis.exceptions.Con...
ERROR tests/test_favorites.py::test_get_favorites - redis.exceptions.Connecti...
ERROR tests/test_inventory_routes.py::test_get_inventory - redis.exceptions.C...
ERROR tests/test_inventory_routes.py::test_create_inventory - redis.exception...
ERROR tests/test_inventory_routes.py::test_update_inventory - redis.exception...
ERROR tests/test_inventory_routes.py::test_delete_inventory - redis.exception...
ERROR tests/test_kits.py::test_create_character - redis.exceptions.Connection...
ERROR tests/test_newsletter.py::test_get_newsletter_emails - redis.exceptions...
ERROR tests/test_purchase_routes.py::test_create_purchase - redis.exceptions....
ERROR tests/test_purchases.py::test_list_purchases - redis.exceptions.Connect...
ERROR tests/test_purchases.py::test_checkout - redis.exceptions.ConnectionErr...
ERROR tests/test_resource_routes.py::test_post_and_get_resource - redis.excep...
ERROR tests/test_reviews.py::test_post_review - redis.exceptions.ConnectionEr...
ERROR tests/test_user_settings.py::test_update_email - redis.exceptions.Conne...
ERROR tests/test_user_settings.py::test_update_password - redis.exceptions.Co...
ERROR tests/test_user_settings.py::test_delete_account - redis.exceptions.Con...
============= 2 failed, 22 passed, 19 errors in 159.05s (0:02:39) =============
