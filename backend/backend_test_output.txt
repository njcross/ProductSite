============================= test session starts =============================
platform win32 -- Python 3.10.11, pytest-8.3.5, pluggy-1.5.0
rootdir: C:\Users\njcro\m7project\backend
configfile: pytest.ini
plugins: Flask-Dance-6.0.0, flask-1.3.0
collected 40 items

tests\test_auth.py EEE                                                   [  7%]
tests\test_auth_routes.py E                                              [ 10%]
tests\test_cart.py E                                                     [ 12%]
tests\test_cart_routes.py EEEE                                           [ 22%]
tests\test_content.py E                                                  [ 25%]
tests\test_content_routes.py E                                           [ 27%]
tests\test_favorite.py E                                                 [ 30%]
tests\test_favorite_routes.py E                                          [ 32%]
tests\test_favorites.py E                                                [ 35%]
tests\test_health_routes.py EE                                           [ 40%]
tests\test_inventory_routes.py EEEE                                      [ 50%]
tests\test_kit_routes.py E                                               [ 52%]
tests\test_kits.py EE                                                    [ 57%]
tests\test_newsletter.py EE                                              [ 62%]
tests\test_newsletter_routes.py EEE                                      [ 70%]
tests\test_purchase_routes.py EE                                         [ 75%]
tests\test_purchases.py EE                                               [ 80%]
tests\test_review_routes.py E                                            [ 82%]
tests\test_reviews.py EE                                                 [ 87%]
tests\test_user_settings.py EEEE                                         [ 97%]
tests\test_user_settings_routes.py E                                     [100%]

=================================== ERRORS ====================================
_______________________ ERROR at setup of test_register _______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
---------------------------- Captured stdout setup ----------------------------
CORS_ORIGIN: ['http://localhost:3000', 'http://www.localhost:3000']
DB setup failed: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
[SQL: DESCRIBE `marvel`.`age_options`]
(Background on this error at: https://sqlalche.me/e/20/4xp6)
________________________ ERROR at setup of test_login _________________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
______________________ ERROR at setup of test_auth_basic ______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
__________________ ERROR at setup of test_auth_routes_basic ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
______________________ ERROR at setup of test_cart_basic ______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_get_empty_cart ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_____________________ ERROR at setup of test_add_to_cart ______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_________________ ERROR at setup of test_update_cart_quantity _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_delete_cart_item ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_content_basic _____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_________________ ERROR at setup of test_content_routes_basic _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_favorite_basic ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
________________ ERROR at setup of test_favorite_routes_basic _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_get_favorites _____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_________________ ERROR at setup of test_health_routes_basic __________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_____________________ ERROR at setup of test_health_check _____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_get_inventory _____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_create_inventory ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_update_inventory ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_delete_inventory ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_kit_routes_basic ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_create_character ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_get_characters ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
________________ ERROR at setup of test_get_newsletter_emails _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_newsletter_basic ___________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
________________ ERROR at setup of test_unsubscribe_newsletter ________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_______________ ERROR at setup of test_newsletter_routes_basic ________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_______________ ERROR at setup of test_newsletter_subscription ________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
________________ ERROR at setup of test_purchase_routes_basic _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_create_purchase ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_list_purchases ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_______________________ ERROR at setup of test_checkout _______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_________________ ERROR at setup of test_review_routes_basic __________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_____________________ ERROR at setup of test_get_reviews ______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_____________________ ERROR at setup of test_post_review ______________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_________________ ERROR at setup of test_user_settings_basic __________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
_____________________ ERROR at setup of test_update_email _____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
___________________ ERROR at setup of test_update_password ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
____________________ ERROR at setup of test_delete_account ____________________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
______________ ERROR at setup of test_user_settings_routes_basic ______________

self = <sqlalchemy.engine.base.Connection object at 0x000001C76B7100D0>
dialect = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLDialect_mysqlconnector object at 0x000001C76B55DC00>
context = <sqlalchemy.dialects.mysql.mysqlconnector.MySQLExecutionContext_mysqlconnector object at 0x000001C76B710F70>
statement = 'DESCRIBE `marvel`.`age_options`', parameters = [immutabledict({})]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\lib\site-packages\sqlalchemy\engine\base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           mysql.connector.errors.DatabaseError: 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def app():
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_ENGINE_OPTIONS": {"pool_pre_ping": True},
        })
    
        with app.app_context():
>           _db.drop_all()

tests\conftest.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\flask_sqlalchemy\extension.py:917: in drop_all
    self._call_for_binds(bind_key, "drop_all")
venv\lib\site-packages\flask_sqlalchemy\extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv\lib\site-packages\sqlalchemy\sql\schema.py:5953: in drop_all
    bind._run_ddl_visitor(
venv\lib\site-packages\sqlalchemy\engine\base.py:3249: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\lib\site-packages\sqlalchemy\engine\base.py:2456: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv\lib\site-packages\sqlalchemy\sql\visitors.py:664: in traverse_single
    return meth(obj, **kw)
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in visit_metadata
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1081: in <listcomp>
    unsorted_tables = [t for t in tables if self._can_drop_table(t)]
venv\lib\site-packages\sqlalchemy\sql\ddl.py:1157: in _can_drop_table
    return not self.checkfirst or self.dialect.has_table(
venv\lib\site-packages\sqlalchemy\engine\reflection.py:89: in cache
    return fn(self, con, *args, **kw)
venv\lib\site-packages\sqlalchemy\dialects\mysql\base.py:2849: in has_table
    with connection.exec_driver_sql(
venv\lib\site-packages\sqlalchemy\engine\base.py:1776: in exec_driver_sql
    ret = self._execute_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1843: in _execute_context
    return self._exec_single_context(
venv\lib\site-packages\sqlalchemy\engine\base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
venv\lib\site-packages\sqlalchemy\engine\base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\lib\site-packages\sqlalchemy\engine\base.py:1964: in _exec_single_context
    self.dialect.do_execute(
venv\lib\site-packages\sqlalchemy\engine\default.py:945: in do_execute
    cursor.execute(statement, parameters)
venv\lib\site-packages\mysql\connector\cursor.py:537: in execute
    self._handle_result(self._connection.cmd_query(stmt))
venv\lib\site-packages\mysql\connector\opentelemetry\context_propagation.py:97: in wrapper
    return method(cnx, *args, **kwargs)
venv\lib\site-packages\mysql\connector\connection.py:872: in cmd_query
    result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <mysql.connector.connection.MySQLConnection object at 0x000001C76B711150>
packet = bytearray(b"t\x00\x00\x01\xff\x94\x06#HY000Table \'marvel\'.\'age_options\' was skipped since its definition is being modified by concurrent DDL statement")

    def _handle_result(self, packet: bytes) -> ResultType:
        """Handle a MySQL Result
    
        This method handles a MySQL result, for example, after sending the
        query command. OK and EOF packets will be handled and returned. If
        the packet is an Error packet, an Error-exception will be
        raised.
    
        The dictionary returned of:
        - columns: column information
        - eof: the EOF-packet information
    
        Returns a dict()
        """
        if not packet or len(packet) < 4:
            raise InterfaceError("Empty response")
        if packet[4] == 0:
            return self._handle_ok(packet)
        if packet[4] == 251:
            filename = packet[5:].decode()
            return self._handle_load_data_infile(filename)
        if packet[4] == 254:
            return self._handle_eof(packet)
        if packet[4] == 255:
>           raise get_exception(packet)
E           sqlalchemy.exc.DatabaseError: (mysql.connector.errors.DatabaseError) 1684 (HY000): Table 'marvel'.'age_options' was skipped since its definition is being modified by concurrent DDL statement
E           [SQL: DESCRIBE `marvel`.`age_options`]
E           (Background on this error at: https://sqlalche.me/e/20/4xp6)

venv\lib\site-packages\mysql\connector\connection.py:648: DatabaseError
=========================== short test summary info ===========================
ERROR tests/test_auth.py::test_register - sqlalchemy.exc.DatabaseError: (mysq...
ERROR tests/test_auth.py::test_login - sqlalchemy.exc.DatabaseError: (mysql.c...
ERROR tests/test_auth.py::test_auth_basic - sqlalchemy.exc.DatabaseError: (my...
ERROR tests/test_auth_routes.py::test_auth_routes_basic - sqlalchemy.exc.Data...
ERROR tests/test_cart.py::test_cart_basic - sqlalchemy.exc.DatabaseError: (my...
ERROR tests/test_cart_routes.py::test_get_empty_cart - sqlalchemy.exc.Databas...
ERROR tests/test_cart_routes.py::test_add_to_cart - sqlalchemy.exc.DatabaseEr...
ERROR tests/test_cart_routes.py::test_update_cart_quantity - sqlalchemy.exc.D...
ERROR tests/test_cart_routes.py::test_delete_cart_item - sqlalchemy.exc.Datab...
ERROR tests/test_content.py::test_content_basic - sqlalchemy.exc.DatabaseErro...
ERROR tests/test_content_routes.py::test_content_routes_basic - sqlalchemy.ex...
ERROR tests/test_favorite.py::test_favorite_basic - sqlalchemy.exc.DatabaseEr...
ERROR tests/test_favorite_routes.py::test_favorite_routes_basic - sqlalchemy....
ERROR tests/test_favorites.py::test_get_favorites - sqlalchemy.exc.DatabaseEr...
ERROR tests/test_health_routes.py::test_health_routes_basic - sqlalchemy.exc....
ERROR tests/test_health_routes.py::test_health_check - sqlalchemy.exc.Databas...
ERROR tests/test_inventory_routes.py::test_get_inventory - sqlalchemy.exc.Dat...
ERROR tests/test_inventory_routes.py::test_create_inventory - sqlalchemy.exc....
ERROR tests/test_inventory_routes.py::test_update_inventory - sqlalchemy.exc....
ERROR tests/test_inventory_routes.py::test_delete_inventory - sqlalchemy.exc....
ERROR tests/test_kit_routes.py::test_kit_routes_basic - sqlalchemy.exc.Databa...
ERROR tests/test_kits.py::test_create_character - sqlalchemy.exc.DatabaseErro...
ERROR tests/test_kits.py::test_get_characters - sqlalchemy.exc.DatabaseError:...
ERROR tests/test_newsletter.py::test_get_newsletter_emails - sqlalchemy.exc.D...
ERROR tests/test_newsletter.py::test_newsletter_basic - sqlalchemy.exc.Databa...
ERROR tests/test_newsletter_routes.py::test_unsubscribe_newsletter - sqlalche...
ERROR tests/test_newsletter_routes.py::test_newsletter_routes_basic - sqlalch...
ERROR tests/test_newsletter_routes.py::test_newsletter_subscription - sqlalch...
ERROR tests/test_purchase_routes.py::test_purchase_routes_basic - sqlalchemy....
ERROR tests/test_purchase_routes.py::test_create_purchase - sqlalchemy.exc.Da...
ERROR tests/test_purchases.py::test_list_purchases - sqlalchemy.exc.DatabaseE...
ERROR tests/test_purchases.py::test_checkout - sqlalchemy.exc.DatabaseError: ...
ERROR tests/test_review_routes.py::test_review_routes_basic - sqlalchemy.exc....
ERROR tests/test_reviews.py::test_get_reviews - sqlalchemy.exc.DatabaseError:...
ERROR tests/test_reviews.py::test_post_review - sqlalchemy.exc.DatabaseError:...
ERROR tests/test_user_settings.py::test_user_settings_basic - sqlalchemy.exc....
ERROR tests/test_user_settings.py::test_update_email - sqlalchemy.exc.Databas...
ERROR tests/test_user_settings.py::test_update_password - sqlalchemy.exc.Data...
ERROR tests/test_user_settings.py::test_delete_account - sqlalchemy.exc.Datab...
ERROR tests/test_user_settings_routes.py::test_user_settings_routes_basic - s...
============================= 40 errors in 16.53s =============================
